Go to the [first](https://alexott.net/ru/emacs/emacs-manual/emacs_1.html), [previous](https://alexott.net/ru/emacs/emacs-manual/emacs_13.html), [next](https://alexott.net/ru/emacs/emacs-manual/emacs_15.html), [last](https://alexott.net/ru/emacs/emacs-manual/emacs_46.html) section, [table of contents](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html).

---

# [Уничтожение и перемещение текста](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html#TOC62)

_Уничтожение_ означает стирание текста и запись его в _список уничтожений_, из которого он может быть получен с помощью _восстановления_. Некоторые системы, ставшие недавно популярными, используют для обозначения этих операций термины "вырезка" и "вставка".

Самый распространенный способ переноса или копирования текста в Emacs --- сначала уничтожить его, а потом восстановить в одном или нескольких местах. Это очень надежно, так как все уничтоженные за последнее время куски текста запоминаются. И это удобно, так как многочисленные команды для уничтожения синтаксических единиц могут быть также использованы и для их перемещения. Но есть и другие способы копирования текста для особых целей.

Emacs хранит единый для всех буферов список уничтожений, так что вы можете уничтожить текст в одном буфере и восстановить его в другом.

## [Удаление и уничтожение](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html#TOC63)

Большинство команд, которые стирают текст из буфера, сохраняют его в списке уничтожений, чтобы вы могли перенести или скопировать его в другие части буфера. Эти команды известны как команды _уничтожения_. Остальные команды, стирающие текст, не записывают его в список уничтожений; они известны как команды _удаления_. (Такое отличие делается только для стирания текста в буфере). Если вы уничтожили или удалили текст по ошибке, вы можете использовать команду C-x u (`undo`) для отмены изменений (see section [Отмена сделанных изменений](https://alexott.net/ru/emacs/emacs-manual/emacs_9.html#SEC28)).

Команды удаления включают C-d (`delete-char`) и DEL (`delete-backward-char`), которые удаляют только один знак за один раз, и те команды, которые удаляют только пробелы или ограничители новой строки. Команды, которые могут уничтожить существенное количество нетривиальных данных, обычно являются командами уничтожения. Имена команд и их описания используют слова `kill' и `delete', чтобы пояснять что они делают.

### [Удаление](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html#TOC64)

C-d

Удалить следующий знак (`delete-char`).

DEL

Удалить предыдущий знак (`delete-backward-char`).

M-\

Удалить все пробелы и табуляцию вокруг точки (`delete-horizontal-space`).

M-SPC

Удалить пробелы и табуляцию вокруг точки, оставляя один пробел (`just-one-space`).

C-x C-o

Удалить пустые строки вокруг текущей строки (`delete-blank-lines`).

M-^

Объединить две строки, удаляя находящийся между ними ограничитель новой строки и любой отступ, следующий за ним (`delete-indentation`).

Самые основные команды удаления -- это C-d (`delete-char`) и DEL (`delete-backward-char`). C-d удаляет знак после точки, над которым находится курсор. Точка не передвигается. DEL удаляет знак перед курсором и передвигает точку назад. Ограничитель новой строки может быть удален точно также, как и любой другой знак в буфере. Удаление ограничителя новой строки объединяет две строки. Фактически C-d и DEL не всегда являются командами удаления; если им дать аргумент, они уничтожают, так как этим способом они могут стереть уже более одного знака.

Другие команды удаления -- это те, что удаляют только пробельные знаки: пробелы, табуляцию и ограничители новых строк. M-\ (`delete-horizontal-space`) удаляет все пробелы и символы табуляции перед и после точки. M-SPC (`just-one-space`) делает то же самое, но оставляет одиночный пробел после точки, независимо от количества пробелов, существовавших прежде (даже если оно было равно нулю).

C-x C-o (`delete-blank-lines`) уничтожает все пустые строки после текущей строки. Если текущая строка пустая, то также уничтожает все пустые строки, предшествующие текущей строке (оставляя одну пустую строку, текущую).

M-^ (`delete-indentation`) объединяет текущую строку и предшествующую ей, удаляя ограничитель новой строки и все окружающие пробелы, обычно оставляя одиночный пробел. See section [Отступы](https://alexott.net/ru/emacs/emacs-manual/emacs_25.html#SEC213).

### [Уничтожение строк](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html#TOC65)

C-k

Уничтожить остаток строки, либо одну или несколько строк (`kill-line`).

Простейшей командой уничтожения является C-k. Если она дается в начале строки, то уничтожает весь текст на строке, оставляя ее пустой. Если команда дана на пустой строке, то уничтожает всю строку, включая ее ограничитель. Чтобы уничтожить непустую строку целиком, перейдите в ее начало и нажмите C-k дважды.

В более общем виде, C-k уничтожает все от точки вплоть до конца строки, если это не происходит в конце строки. В этом случае она уничтожает ограничитель новой строки, следующий за строкой, таким образом происходит слияние следующей строки с текущей. При решении вопроса о том, какой случай применять, невидимые пробелы и табуляция в конце строки игнорируются, так, если точка выглядит стоящей в конце строки, вы можете быть уверены, что C-k уничтожит перевод строки.

Если C-k будет присвоен положительный аргумент, она уничтожит ровно столько строк вместе со следующими за ними ограничителями (однако, текст на текущей строке перед точкой сохраняется). С отрицательным аргументом -n она уничтожает n строк, предшествующих текущей (вместе с текстом на текущей строке перед точкой). Таким образом, C-u - 2 C-k в начале строки уничтожает две предыдущие строки.

C-k с аргументом, равным нулю, уничтожает текст перед точкой на текущей строке.

Если переменная `kill-whole-line` не равна `nil`, C-k в самом начале строки уничтожает всю эту строку, включая последующий перевод строки. Эта переменная обычно равна `nil`.

### [Другие команды уничтожения](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html#TOC66)

C-w

Уничтожить область (от точки до метки) (`kill-region`).

M-d

Уничтожить слово (`kill-word`). See section [Слова](https://alexott.net/ru/emacs/emacs-manual/emacs_26.html#SEC218).

M-DEL

Уничтожить предыдущее слово (`backward-kill-word`).

C-x DEL

Уничтожить назад до начала предложения (`backward-kill-sentence`). See section [Предложения](https://alexott.net/ru/emacs/emacs-manual/emacs_26.html#SEC219).

M-k

Уничтожить до конца предложения (`kill-sentence`).

C-M-k

Уничтожить s-выражение (`kill-sexp`). See section [Списки и s-выражения](https://alexott.net/ru/emacs/emacs-manual/emacs_27.html#SEC251).

M-z знак

Уничтожить вплоть до следующего появления знака (`zap-to-char`).

C-w (`kill-region`) -- очень распространенная команда уничтожения, которая уничтожает все между точкой и меткой. С помощью этой команды вы можете уничтожить любую непрерывную последовательность знаков, если сначала установите метку в одном ее конце и отправитесь в другой конец.

Удобный способ уничтожения -- это уничтожение скомбинированное с поиском: M-z (`zap-to-char`) считывает знак и уничтожает от точки вплоть до следующего появления этого знака (и включая его) в буфере. Числовой аргумент действует как счетчик повторов. Отрицательный аргумент означает поиск в обратную сторону и уничтожение текста перед точкой.

Могут уничтожаться другие синтаксические единицы: слова, с помощью M-DEL и M-d (see section [Слова](https://alexott.net/ru/emacs/emacs-manual/emacs_26.html#SEC218)); s-выражения, с помощью C-M-k (see section [Списки и s-выражения](https://alexott.net/ru/emacs/emacs-manual/emacs_27.html#SEC251)); и предложения, с помощью C-x DEL и M-k (see section [Предложения](https://alexott.net/ru/emacs/emacs-manual/emacs_26.html#SEC219)).

Вы можете использовать команды уничтожения в буферах, доступных только для чтения. На самом деле они не изменяют буфер и подают звуковой сигнал, чтобы предупредить вас об этом, но они действительно копируют текст, который вы попытались уничтожить, в список уничтожений, так что вы можете восстановить его в других буферах. Большинство команд уничтожения передвигают точку по тексту, который они копируют таким способом, поэтому последовательные команды уничтожения, как обычно, создают единое вхождение в списке уничтожений.

## [Восстановление](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html#TOC67)

_Восстановление_ возвращает обратно текст, который был ранее уничтожен. Это то же самое, что в других системах называется "вставкой". Обычный способ копирования или перемещения текста --- уничтожить его, а затем восстановить один или несколько раз.

C-y

Восстановить последний уничтоженный текст (`yank`).

M-y

Заменить только что восстановленный текст предшествующим куском уничтоженного текста (`yank-pop`).

M-w

Сохранить область как последний уничтоженный текст без фактического уничтожения (`kill-ring-save`).

C-M-w

Добавить следующее уничтожение к последнему куску уничтоженного текста (`append-next-kill`).

### [Список уничтожений](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html#TOC68)

Весь уничтоженный текст записывается в _кольцевой список уничтожений_, список блоков текста, который был уничтожен. Существует только один список уничтожений, используемый во всех буферах, таким образом вы можете уничтожить текст в одном буфере и восстановить его в другом. Это обычный способ перемещения текста из одного файла в другой. (See section [Накопление текста](https://alexott.net/ru/emacs/emacs-manual/emacs_14.html#SEC71), для получения информации о других способах).

Команда C-y (`yank`) вновь вставляет текст, уничтоженный самым последним. Она оставляет курсор в конце текста, метка устанавливается в его начале. See section [Пометка и область](https://alexott.net/ru/emacs/emacs-manual/emacs_13.html#SEC55).

C-u C-y оставляет курсор перед текстом и устанавливает метку после него. Это происходит, только если аргумент задан с помощью просто C-u. Любой другой вид аргумента, включая C-u и цифры, обозначают восстановление уничтоженного ранее (see section [Восстановление ранее уничтоженного](https://alexott.net/ru/emacs/emacs-manual/emacs_14.html#SEC70)).

Если вы хотите скопировать блок текста, вы можете использовать M-w (`kill-ring-save`), которая копирует область в список уничтожений без удаления его из буфера. Это приблизительный эквивалент C-w, за которой следует C-x u, за исключением того, что M-w не изменяет историю восстановлений и не изменяет на время экран.

### [Добавление уничтожений](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html#TOC69)

Обычно каждая команда уничтожения добавляет новый блок в список уничтожений. Однако, две или более команды уничтожения подряд объединяют текст в единый элемент, так что одиночная C-y возьмет весь его обратно таким, каким он был перед уничтожением.

Таким образом, если вы хотите восстановить текст как одно целое, вы не должны уничтожать весь этот текст одной командой; вы можете продолжать уничтожение строки за строкой или слова за словом до тех пор, пока не уничтожите весь текст полностью, и вы можете получить его обратно сразу целиком.

Команды, которые уничтожают текст вперед от точки, добавляют уничтоженное в конец предыдущего уничтоженного текста. Команды, которые уничтожают назад от точки, добавляют это в начало. Таким образом, любая последовательность смешанных команд уничтожения перед точкой и после нее объединяет весь уничтоженный текст в один элемент без переупорядочения. Числовой аргумент не прерывает последовательность добавления уничтожений. Например, предположим, что буфер содержит такой текст:

Это пример строки -!-с образцом текста.

с точкой, показанной как -!-. Если вы наберете M-d M-DEL M-d M-DEL, уничтожая по очереди вперед и назад, то в конце получите `пример строки с образцом' в качестве одного вхождения в списке уничтожений и `Это текста.' в буфере. (Обратите внимание на двойной пробел, который вы можете очистить с помощью M-SPC или M-q.)

Другой способ уничтожить тот же текст -- переместиться назад на два слова с помощью M-b M-b и уничтожить все четыре слова вперед командой C-u M-d. Это дает такой же результат в буфере и в списке уничтожений. M-f M-f C-u M-DEL уничтожает тот же текст, проходя все время назад; и опять результат будет тем же. Текст в элементе списка уничтожений всегда имеет тот же порядок, что он имел в буфере до того, как вы его уничтожили.

Если команда уничтожения отделена от предыдущей другими командами (не просто числовым аргументом), то она начинает новый элемент в списке уничтожений. Но вы можете заставить эту команду уничтожения добавлять текст к предыдущему элементу, набрав перед ней команду C-M-w (`append-next-kill`). C-M-w приказывает следующей команде, если это команда уничтожения, добавить уничтоженный ею текст к последнему уничтоженному тексту вместо того, чтобы начинать новый элемент. С помощью C-M-w вы можете уничтожить несколько отдельных кусков текста и накопить их для дальнейшего восстановления в одном месте.

Команда уничтожения, следующая после M-w, не добавляет к тексту, который M-w скопировала в список уничтожений.

### [Восстановление ранее уничтоженного](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html#TOC70)

Для того чтобы вернуть уничтоженный текст, который уже не является последним уничтоженным, используйте команду M-y (`yank-pop`). Она берет прежде восстановленный текст, и заменяет его текстом более раннего уничтожения. Так, чтобы вернуть текст, предшествующий последнему уничтоженному, сначала используйте C-y, чтобы восстановить последнее уничтожение, а затем M-y, чтобы заменить его предыдущим. M-y может использоваться только после C-y или другой M-y.

M-y можно понимать в терминах указателя на "последнее восстановление", который указывает на элемент в списке уничтожения. Каждый раз, когда вы уничтожаете, указатель на "последнее восстановление" передвигается в последний созданный элемент в начале списка. C-y восстанавливает элемент, на который ссылается указатель "последнего восстановления". M-y двигает указатель на "последнее восстановление" к другому элементу, и текст в буфере соответственно изменяется. Достаточное количество команд M-y может переместить указатель к любому элементу в списке, таким образом, вы можете получить любой элемент в буфере. Когда наконец указатель достигает последнего элемента списка, следующая команда M-y снова помещает его на первый элемент.

M-y двигает указатель на "последнее восстановление" по списку, но это не меняет порядок элементов, которые всегда идут от самого последнего уничтожения до самого старого, которое еще хранится.

M-y может получить числовой аргумент, который говорит, на сколько элементов вперед продвинуть указатель на "последнее восстановление". Отрицательный аргумент двигает этот указатель по направлению к началу списка; от начала списка он двигает к последнему элементу и продолжает движение вперед оттуда.

Как только искомый текст помещен в буфер, вы можете прекратить запускать команды M-y, и текст останется там. Это просто копия элемента списка уничтожения, поэтому редактирование его в буфере не изменяет содержимое этого списка. До тех пор, пока не делается новое уничтожение, указатель на "последнее восстановление" остается в том же самом месте в списке уничтожений, таким образом, повторение C-y восстановит еще одну копию того же самого старого уничтожения.

Если вы знаете, сколько команд M-y необходимо набрать, чтобы найти интересующий вас текст, вы можете восстановить этот текст за один шаг, используя C-y с числовым аргументом. C-y с аргументом восстанавливает текст, записанный в списке уничтожения на заданное число элементов назад. Таким образом, C-u 2 C-y достает следующий за последним блок уничтоженного текста. Это эквивалентно C-y M-y. C-y c числовым аргументом начинает подсчет от указателя на "последнее восстановление" и устанавливает этот указатель на элемент, который эта команда восстанавливает.

Длина списка уничтожений управляется переменной `kill-ring-max`; не может быть записано больше блоков текста, чем определено этой величиной.

Действительное содержимое списка уничтожений хранится в переменной `kill-ring`; вы можете просмотреть все содержимое списка уничтожений с помощью команды C-h v kill-ring.

## [Накопление текста](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html#TOC71)

Обычно мы копируем или переносим текст путем его уничтожения и восстановления, но существуют и другие способы, удобные для копирования одного блока текста во многие места или для копирования многих рассеянных блоков текста в одно место. Чтобы скопировать один блок во много мест, запишите его в регистр (see section [Регистры](https://alexott.net/ru/emacs/emacs-manual/emacs_15.html#SEC73)). Здесь мы описываем команды для накопления разбросанных кусков текста в буфер или в файл.

M-x append-to-buffer

Добавить область в заданный буфер после точки.

M-x prepend-to-buffer

Добавить область в заданный буфер перед точкой.

M-x copy-to-buffer

Копировать область в заданный буфер, удаляя старое содержимое буфера.

M-x insert-buffer

Вставить содержимое заданного буфера в текущий буфер в точке.

M-x append-to-file

Добавить область в конец заданного файла.

Для накопления текста в буфере используется M-x append-to-buffer. Она считывает имя буфера, а затем вставляет в этот буфер копию области. Если буфер с таким именем не существует, то `append-to-buffer` создаст его. Текст вставляется в то место в этом буфере, где находится точка. Если вы использовали этот буфер для редактирования, скопированный текст вставляется в середину текста, где оказалась точка.

Точка в этом буфере остается в конце копируемого текста, таким образом, последовательное использование `append-to-buffer` накапливает текст в заданном буфере в том же самом порядке, в котором части были скопированы. Строго говоря, `append-to-buffer` не всегда добавляет к тексту, уже находящемуся в буфере -- она добавляет, если точка находится в конце этого буфера. Однако, если `append-to-buffer` является единственной командой, которую вы используете для изменения буфера, точка всегда расположена в конце.

M-x prepend-to-buffer подобна `append-to-buffer` за исключением того, что точка в другом буфере остается перед скопированным текстом, таким образом, последовательное применение этой команды добавляет текст в обратном порядке. M-x copy-to-buffer действует так же, за исключением того, что любой существующий текст в другом буфере удаляется, так что в буфере остается лишь вновь скопированный текст.

Чтобы вернуть накопленный текст из другого буфера, используйте команду M-x insert-buffer; она также принимает имя буфера как аргумент. Эта команда вставляет копию текста из буфера с заданным именем в выбранный буфер. Или вы можете выбрать другой буфер для редактирования, возможно, перемещая впоследствии текст из него путем уничтожения. See section [Использование множества буферов](https://alexott.net/ru/emacs/emacs-manual/emacs_20.html#SEC162), для получения базовой информации о буферах.

Вместо накопления текста внутри буфера Emacs вы можете добавить текст непосредственно в файл с помощью команды M-x append-to-file, которая использует имя файла в качестве аргумента. Она добавляет текст области в конец заданного файла. Файл на диске изменяется сразу.

Вы должны использовать `append-to-file` только с файлами, к которым вы _не_ обращаетесь из Emacs. Использование этой команды для файла, к которому обратились из Emacs, может изменить файл без ведома Emacs, что может привести к потере некоторых результатов вашего редактирования.

## [Прямоугольники](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html#TOC72)

@hyphenation{пря-мо-уголь-ни-ка пря-мо-уголь-ник пря-мо-уголь-ни-ки пря-мо-уголь-ни-ков}

Команды для прямоугольников работают с прямоугольными областями текста: всеми знаками между определенной парой столбцов в определенном диапазоне строк. Эти команды предназначены для уничтожения прямоугольников, восстановления уничтоженных прямоугольников, их очистки, заполнения пробелами или текстом, или удаления. Команды для прямоугольников полезны для работы с текстом в многоколоночных форматах и для приведения текста к такому формату или извлечения из него.

Когда вам нужно задать прямоугольник для команды, которая будет с ним работать, вы делаете это, устанавливая метку в одном углу и точку в противоположном. Прямоугольник, описанный таким образом, называется _областью-прямоугольником_, так как вы управляете им почти так же, как и областью. Но помните, что данная комбинация значений точки и метки может быть интерпретирована и как область, и как прямоугольник в зависимости от команды, которая их использует.

Если точка и метка находятся на одном столбце, то прямоугольник, который они ограничивают, пуст. Если они находятся на одной строке, то прямоугольник имеет высоту в одну строку. Эта несимметричность между строками и столбцами происходит из того, что точка (и метка) располагается между двух столбцов, но внутри строки.

C-x r k

Уничтожить текст области-прямоугольника, сохраняя его содержимое в качестве "последнего уничтоженного прямоугольника" (`kill-rectangle`).

C-x r d

Удалить текст области-прямоугольника (`delete-rectangle`).

C-x r y

Восстановить последний уничтоженный прямоугольник, помещая его верхний левый угол в точке (`yank-rectangle`).

C-x r o

Вставить пустое место, заполняя пространство области-прямоугольника (`open-rectangle`). Предыдущее содержимое области-прямоугольника выталкивается вправо.

M-x clear-rectangle

Очистить область-прямоугольник, заменяя ее содержимое пробелами.

M-x delete-whitespace-rectangle

Удалить пробельные знаки в каждой строке заданного прямоугольника, начиная с его самого левого столбца.

C-x r t строка RET

Вставить строку в каждую строку области-прямоугольника (`string-rectangle`).

Операции, работающие с прямоугольниками, делятся на два класса: команды удаления и вставки прямоугольников и команды для пустых прямоугольников.

Существует два способа избавиться от текста в прямоугольнике: вы можете сбросить (удалить) его или записать его как "последний уничтоженный" прямоугольник. Для этого используются две команды C-x r d (`delete-rectangle`) и C-x r k (`kill-rectangle`). В обоих случаях часть каждой строки, которая попала внутрь границ прямоугольника, удаляется, заставляя последующий текст в строке (если он существует) сдвигаться влево.

Заметьте, что "уничтожение" прямоугольника не есть уничтожение в обычном понимании; этот прямоугольник хранится не в списке уничтожений, а в специальном месте, которое в состоянии записать только самое последнее уничтожение прямоугольника. Это происходит из-за того, что восстановление прямоугольника настолько отличается от восстановления линейного текста, что для этого должны использоваться другие команды восстановления, и в этом случае трудно приписать смысл команде, выдающей более ранние уничтожения.

Чтобы вставить последний уничтоженный прямоугольник, наберите C-x r y (`yank-rectangle`). Восстановление прямоугольника -- это противоположность уничтожения. Левый верхний угол задается положением точки. Туда помещается первая строка прямоугольника, вторая строка прямоугольника помещается в позиции точки, но строкой ниже, и так далее. Число затронутых строк определяется высотой записанного прямоугольника.

Вы можете превратить списки из одной колонки в списки из двух колонок, используя уничтожение и восстановление прямоугольников; уничтожьте вторую половину списка как прямоугольник и затем восстановите его рядом с первой строчкой списка. See section [Редактирование текста в две колонки](https://alexott.net/ru/emacs/emacs-manual/emacs_35.html#SEC433), другой способ редактировать двухколоночный текст.

Прямоугольники также могут быть скопированы в регистры и из регистров с помощью C-x r r r и C-x r i r. See section [Запись прямоугольников в регистры](https://alexott.net/ru/emacs/emacs-manual/emacs_15.html#SEC76).

Есть две команды для работы с пустыми прямоугольниками: M-x clear-rectangle, чтобы расписать пробелами существующий текст, и C-x r o (`open-rectangle`), чтобы вставить пустой прямоугольник. Очистка прямоугольника эквивалентна его удалению с последующей вставкой на его место пустого прямоугольника такого же размера.

Команда M-x delete-whitespace-rectangle удаляет горизонтальное пустое пространство, начиная с определенного столбца. Это относится к каждой строке в прямоугольнике, а столбец задается левым краем прямоугольника. Правый край прямоугольника не имеет значения для этой команды.

Команда C-x r t (`M-x string-rectangle`) замещает прямоугольник заданной строкой (вставляя ее один раз в каждую строку). Ширина строки не обязана совпадать с шириной прямоугольника. Если ширина строки меньше, текст после прямоугольника смещается влево; если строка шире прямоугольника, текст после него смещается вправо.

---

Go to the [first](https://alexott.net/ru/emacs/emacs-manual/emacs_1.html), [previous](https://alexott.net/ru/emacs/emacs-manual/emacs_13.html), [next](https://alexott.net/ru/emacs/emacs-manual/emacs_15.html), [last](https://alexott.net/ru/emacs/emacs-manual/emacs_46.html) section, [table of contents](https://alexott.net/ru/emacs/emacs-manual/emacs_toc.html).